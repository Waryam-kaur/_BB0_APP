# -*- coding: utf-8 -*-
"""CMPT3835_Group2_Modeling&Optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18Keczf2Pgau6fnjtAQ-wpx7lavmISVZw

# Step 1 — Imports and Setup
In this step, we imported all essential Python libraries needed for the project. These include tools for data handling (pandas, numpy), visualization (matplotlib, seaborn), machine learning (regression and classification models from sklearn), preprocessing (scaling, encoding), evaluation metrics (accuracy, F1-score, R², MSE), and hyperparameter tuning (StratifiedKFold, RandomizedSearchCV). Importing these libraries prepares the environment so we can load the owl dataset, clean it, create features, train models, tune them, and evaluate performance. Without this setup, none of the later modelling steps would work.
"""

import warnings
warnings.filterwarnings("ignore")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split, StratifiedKFold, RandomizedSearchCV
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.pipeline import Pipeline, make_pipeline
from sklearn.impute import SimpleImputer

from sklearn.metrics import (
    r2_score, mean_squared_error,
    classification_report, confusion_matrix, accuracy_score, f1_score
)

from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import (
    RandomForestRegressor, GradientBoostingRegressor,
    RandomForestClassifier, GradientBoostingClassifier
)
from sklearn.svm import SVR, SVC

"""# 2. Loading the Combined Dataset (Simple Explanation)
In this step, we loaded the final combined CSV file into our notebook using pandas.read_csv(). This file already contains all owl detections and metadata together, so we just read it directly. After loading, we printed the shape to confirm the dataset size and used df.head() to quickly check that the data loaded correctly.
"""

# Load the final combined dataset directly
file_path = "/content/combined_sawwhet_owls.csv"   # AFTER you upload it into Colab

df = pd.read_csv(file_path, low_memory=False)

print("Loaded dataset shape:", df.shape)
df.head()

"""# Step 3 — Identify and Standardize the Motus Tag ID Column

In this step, we checked the dataset to find which column contains the owl identification number (Motus Tag ID). Different files sometimes use different column names such as "motusTagID", "motusTagID_sheet", or "tag_id", so we searched for all possible matches. Once we found the matching columns, we selected the correct one and renamed it to a single standard name — “motusTagID”. This ensures consistency in the entire pipeline because all grouping, merging, and feature calculations depend on this ID. Finally, we converted the column to numeric and confirmed that the combined dataset contains 43 unique tagged owls.
"""

# Find a column that looks like motus tag ID
possible_id_cols = [c for c in df.columns if "motus" in c.lower() and "tag" in c.lower()]
possible_id_cols += [c for c in df.columns if c.lower() in ["tag_id","tagid","motustagid_sheet"]]

print("Possible ID cols:", possible_id_cols)

id_col = possible_id_cols[0]  # take best match
df.rename(columns={id_col: "motusTagID"}, inplace=True)

df["motusTagID"] = pd.to_numeric(df["motusTagID"], errors="coerce")
print("Unique owls in NEW detections:", df["motusTagID"].nunique())

"""# 3. Cleaning and Building a Valid DATETIME Column

In this step, we cleaned the date and time information so we can calculate detection patterns correctly. First, we made a copy of the dataset and checked whether a ready-made DATETIME column already existed. If not, we created it manually by converting the DATE column into proper date format and cleaning the TIME column using a regular expression to extract valid HH:MM:SS times. After converting time into a timedelta format, we combined the cleaned DATE and TIME columns into a new unified DATETIME field. Finally, we verified how many rows contained valid timestamps. This step is essential because accurate timestamps are required to compute each owl’s first and last detection and ultimately calculate stay duration.
"""

df = df.copy()

if "DATETIME" in df.columns:
    df["DATETIME"] = pd.to_datetime(df["DATETIME"], errors="coerce")
else:
    # Make DATE datetime
    if "DATE" in df.columns:
        df["DATE"] = pd.to_datetime(df["DATE"], errors="coerce")
    else:
        df["DATE"] = pd.NaT

    # Make TIME timedelta
    if "TIME" in df.columns:
        df["TIME_clean"] = df["TIME"].astype(str).str.extract(r"(\d{1,2}:\d{2}:\d{2})")[0]
        df["TIME_clean"] = pd.to_timedelta(df["TIME_clean"], errors="coerce")
    else:
        df["TIME_clean"] = pd.to_timedelta(np.nan)

    df["DATETIME"] = df["DATE"] + df["TIME_clean"]

print("Valid DATETIME rows:", df["DATETIME"].notna().sum())
df[["motusTagID","DATE","TIME","DATETIME"]].head()

"""# Step 4: Compute True Stay Duration From RAW Detection Timestamps
**What we did **

In this step, we used the raw MOTUS detection timestamps to calculate how long each owl stayed near the station after it was tagged.

Every owl has many detection rows — each row has a timestamp showing when that owl was detected.
So for each motusTagID, we find:

first detection date → when the owl was first seen

last detection date → when the owl was last seen

**Then we calculate:**
![Screenshot 2025-11-23 214141.png](data:image/png;base64,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)



This gives the true number of days the owl stayed near the station.

**Why we do this**

Because this is real stay duration, not guessed or proxy.
This becomes our true label for regression and classification.
"""

first_det = df.groupby("motusTagID")["DATETIME"].min()
last_det  = df.groupby("motusTagID")["DATETIME"].max()

stay_true = (last_det - first_det).dt.total_seconds() / (3600*24)
stay_true = stay_true.clip(lower=0)   # no negatives

stay_true = stay_true.reset_index()
stay_true.columns = ["motusTagID","stay_duration_days"]

print("True stay durations computed for owls:", stay_true.shape[0])
stay_true.head()

"""# Step 5 — Aggregating Owl-Level Features.

In this step, we convert the raw detection-level data into one row per owl, containing meaningful statistical features. Since each owl appears many times in the dataset (multiple detections), we calculate summary statistics such as mean and standard deviation for numeric columns like snr, sigsd, freq, slop, burstSlop, hour, etc. Using safe_mean and safe_std, we ensure all values are converted safely to numeric before aggregating. We also include a detections_count column that tells us how many detections each owl has. Finally, we group everything by motusTagID and create a single, clean feature table that is ready for modelling.
"""

def safe_mean(s): return pd.to_numeric(s, errors="coerce").mean()
def safe_std(s):  return pd.to_numeric(s, errors="coerce").std()

num_cols = ["snr","sigsd","freq","freqsd","slop","burstSlop","antBearing","port","nodeNum","runLen","hour"]
num_cols = [c for c in num_cols if c in df.columns]

agg_dict = {
    "detections_count": ("motusTagID","size")
}
for c in num_cols:
    agg_dict[f"{c}_mean"] = (c, safe_mean)
    agg_dict[f"{c}_std"]  = (c, safe_std)

owl_features = df.groupby("motusTagID").agg(**agg_dict).reset_index()

print("Owl-level feature table shape:", owl_features.shape)
owl_features.head()

"""# Step 6 — Load Old Metadata & Standardize motusTagID

In this step, we loaded the old cleaned metadata file (clean_df_selected.csv) because it contains important biological information such as age, sex, weight, species, marker type, etc. First, we read the file into a DataFrame and printed its shape to confirm it loaded correctly. Then, because the old file uses slightly different column names for tag IDs, we automatically searched for any column that looks like a motus tag ID (for example, motusTagID, motusTagID_sheet, or tag_id). After identifying the correct column, we renamed it to motusTagID so that both datasets use the same key. Next, we converted the tag ID values to numeric to avoid merge issues. Finally, since the old metadata contains several rows per owl, we kept only one row per motusTagID (usually the first occurrence). This gives us a clean table where each owl has exactly one metadata record we can merge with the new dataset for modelling.
"""

old_path = "clean_df_selected.csv"

df_old = pd.read_csv(old_path, low_memory=False)
print("Old metadata shape:", df_old.shape)

# standardize its ID col too
possible_old_ids = [c for c in df_old.columns if "motus" in c.lower() and "tag" in c.lower()]
possible_old_ids += [c for c in df_old.columns if c.lower() in ["tag_id","tagid","motustagid_sheet"]]
old_id_col = possible_old_ids[0]

df_old.rename(columns={old_id_col:"motusTagID"}, inplace=True)
df_old["motusTagID"] = pd.to_numeric(df_old["motusTagID"], errors="coerce")

# take ONE metadata row per owl
meta_one = df_old.groupby("motusTagID").first().reset_index()

print("Old metadata unique owls:", meta_one["motusTagID"].nunique())
meta_one.head()

"""# Step 7 — Merging Features, True Stay Duration & Metadata (Final Dataset Build)

In this step, we combine all the processed information into one final modelling dataset. First, we take the owl-level behavioral features we engineered earlier (such as mean SNR, detection counts, etc.). Then we merge these features with the true stay-duration table, which contains the number of days each owl stayed based on the first and last detection timestamps. After that, we bring in the old metadata file, which includes additional biological and tag-related attributes (sex, age, species, weight, tagging details). All merges are done using motusTagID as the key. The final output is a clean, owl-level dataset containing 43 unique owls and 115 combined features, ready to be used for regression and classification modelling.
"""

owl_df = owl_features.merge(stay_true, on="motusTagID", how="left")
owl_df = owl_df.merge(meta_one, on="motusTagID", how="left", suffixes=("","_meta"))

print("Final dataset shape:", owl_df.shape)
print("Final unique owls:", owl_df["motusTagID"].nunique())
owl_df.head()

"""# Step 8: Categorizing Owls into Residency Types (Vagrant / Migrant / Resident)

After calculating each owl’s true stay duration in days, we converted these continuous values into meaningful residency categories. This helps us answer the second objective of the project:
➡️ Classify each owl as Vagrant, Migrant, or Resident based on how long it stayed near the station.

**How it works**

We created 3 stay-duration ranges (bins):

0–3 days → Vagrant (very short stay, passes quickly)

3–7 days → Migrant (moderate stay, typical migratory stopover)

7+ days → Resident (long stay, behaves like a local bird)

We used pd.cut(), a pandas function that categorizes continuous numbers into labeled groups.

**Why this matters**

This step transforms numeric stay duration into biologically meaningful behaviour labels so we can:
✔ Train a classification model later
✔ Compare migration behaviour
✔ Visualize how many owls belong to each category

So this step is the bridge between regression output (stay duration days) and classification target (residency type).
"""

bins = [0, 3, 7, np.inf]
labels = ["Vagrant","Migrant","Resident"]

owl_df["ResidencyType_true"] = pd.cut(
    owl_df["stay_duration_days"],
    bins=bins, labels=labels, include_lowest=True
)

print(owl_df["ResidencyType_true"].value_counts())

"""# Step 9. Preparing Data for Regression (Feature & Label Extraction)

**What we did:**
We separated the target variable (stay_duration_days) from the rest of the dataset and prepared the numerical features needed for regression.

1. Selected the target (y):

We used stay_duration_days as our prediction label for the regression model.

2. Dropped unwanted columns:

We removed:

motusTagID → ID column, not useful for prediction

stay_duration_days → the target (we can't use it as input)

ResidencyType_true → classification label (for later use, not for regression)

3. Kept only numerical features:

Machine learning models require numerical input.

We filtered the dataset to keep only numeric columns.

4. Dropped empty columns:

Removed columns that were entirely blank using x.dropna(axis=1, how="all").

5. Handled missing values:

Used median imputation to fill any missing numeric values.

Median is robust to outliers and works well for noisy sensor data like Motus.

6. Train–test split:

Divided the dataset into:

80% → training

20% → testing

Ensures models are evaluated fairly.

**Why this step matters:**
This step creates a clean, numeric, and model-ready feature matrix (X) and target vector (y).
Without this preprocessing, no regression model would work properly.
"""

y_reg = owl_df["stay_duration_days"]

# drop identifiers + label cols
drop_cols = ["motusTagID","stay_duration_days","ResidencyType_true"]
X = owl_df.drop(columns=[c for c in drop_cols if c in owl_df.columns], errors="ignore")

# numeric only
X = X.select_dtypes(include=[np.number]).copy()
X = X.dropna(axis=1, how="all")

# median impute
imputer = SimpleImputer(strategy="median")
X_imp = pd.DataFrame(imputer.fit_transform(X), columns=X.columns, index=X.index)

X_train, X_test, y_train, y_test = train_test_split(
    X_imp, y_reg, test_size=0.2, random_state=42
)

print("X shape:", X_imp.shape)
print("y shape:", y_reg.shape)

"""# Step 10 – Training Multiple Regression Models & Comparing Their Performance

In this step, we trained several different regression models to predict each owl’s stay duration in days. We created a dictionary called reg_models that contains five popular algorithms — Linear Regression, Decision Tree Regressor, Gradient Boosting Regressor, SVR (using a pipeline with scaling), and Random Forest Regressor. We then looped through each model, fitted it using the training data (X_train, y_train), and generated predictions on the test set. For every model, we calculated two important metrics: R² score (how well the model explains variance) and RMSE (the typical prediction error in days). These results were stored in a list and converted into a table (reg_results) so we can easily see which regression model performs best. This step helps us compare model performance side-by-side and select the strongest candidate for the final prediction task.
"""

reg_models = {
    "LinearRegression": LinearRegression(),
    "DecisionTree": DecisionTreeRegressor(max_depth=6, random_state=42),
    "GradientBoosting": GradientBoostingRegressor(
        n_estimators=300, learning_rate=0.05, max_depth=4, random_state=42
    ),
    "SVR": make_pipeline(StandardScaler(), SVR(kernel="rbf", C=2.0, epsilon=0.2)),
    "RandomForest": RandomForestRegressor(n_estimators=400, random_state=42, n_jobs=-1)
}

rows = []
pred_store = {}

for name, model in reg_models.items():
    model.fit(X_train, y_train)
    pred = model.predict(X_test)

    r2 = r2_score(y_test, pred)
    rmse = np.sqrt(mean_squared_error(y_test, pred))

    rows.append({"Model":name,"R2":r2,"RMSE":rmse})
    pred_store[name] = pred

reg_results = pd.DataFrame(rows).sort_values("R2", ascending=False)
reg_results

best_reg_name = reg_results.iloc[0]["Model"]
best_reg = reg_models[best_reg_name]
best_pred = pred_store[best_reg_name]

plt.figure(figsize=(6,5))
plt.scatter(y_test, best_pred, alpha=0.7)
plt.xlabel("True stay duration (days)")
plt.ylabel("Predicted stay duration (days)")
plt.title(f"Best Regression Model: {best_reg_name}")
plt.show()

"""# Step 11 – Predicting Stay Duration Using the Best Regression Model

**What we did:**
After testing multiple regression models (Linear Regression, Decision Tree, Gradient Boosting, SVR, Random Forest), we selected the best-performing model based on R² and RMSE scores from our results table.

**Next, we used this best model to:**

Train on the full dataset (X_imp, y_reg)

Predict stay duration for every owl

Add the predictions back into the main dataframe

**Why:**
We want to estimate how long each owl stays after tagging. This predicted value will be used later to classify each owl as Vagrant, Migrant, or Resident.
"""

best_reg.fit(X_imp, y_reg)
owl_df["predicted_stay_days"] = best_reg.predict(X_imp)

owl_df[["motusTagID","stay_duration_days","predicted_stay_days"]].head()

"""# Step 12— Encoding Residency Labels

We converted the ResidencyType_true column into numeric form so classification models can use it. First, we turned the labels into strings, then applied LabelEncoder to map each category (“Vagrant”, “Migrant”, “Resident”) to a number. Finally, we split the data into train and test sets while keeping the class balance using stratify.
"""

y_cls = owl_df["ResidencyType_true"].astype(str)

le = LabelEncoder()
y_cls_enc = le.fit_transform(y_cls)

Xc_train, Xc_test, yc_train, yc_test = train_test_split(
    X_imp, y_cls_enc, test_size=0.2, random_state=42, stratify=y_cls_enc
)

print("Class order:", le.classes_)

"""# Step 13: Hyperparameter Tuning for Classification

In this step, we performed model optimisation to find the best machine-learning classifier for predicting owl residency types (Vagrant, Migrant, Resident). We created a list of candidate models—Logistic Regression, SVC, Random Forest, and Gradient Boosting—each wrapped inside a pipeline (with scaling when needed). For every model, we defined a small hyperparameter search space (like different C values for SVC or different tree depths for Random Forest). Using Stratified K-Fold cross-validation, we ran a RandomizedSearchCV for each model, which tests different parameter combinations and finds the best-performing version of that model. After searching, we saved each model’s best test score and predictions. Finally, we combined all results into a table so we could easily compare which model performed best overall.
"""

candidates = {
    "LogReg": {
        "estimator": Pipeline([
            ("scaler", StandardScaler(with_mean=False)),
            ("clf", LogisticRegression(max_iter=3000, class_weight="balanced"))
        ]),
        "params": {
            "clf__C": np.logspace(-2,2,12),
            "clf__solver": ["lbfgs","liblinear"]
        }
    },
    "SVC": {
        "estimator": Pipeline([
            ("scaler", StandardScaler(with_mean=False)),
            ("clf", SVC(class_weight="balanced"))
        ]),
        "params": {
            "clf__C": np.logspace(-2,2,12),
            "clf__gamma": ["scale","auto"]
        }
    },
    "RandomForest": {
        "estimator": RandomForestClassifier(class_weight="balanced_subsample", random_state=42),
        "params": {
            "n_estimators": [200,400,800],
            "max_depth": [None,6,12,20],
            "min_samples_leaf": [1,2,4,6]
        }
    },
    "GradientBoosting": {
        "estimator": GradientBoostingClassifier(random_state=42),
        "params": {
            "n_estimators": [100,200,400],
            "learning_rate": [0.01,0.05,0.1],
            "max_depth": [2,3,4]
        }
    }
}

kf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

search_results = []
best_models = {}

for name, cfg in candidates.items():
    search = RandomizedSearchCV(
        cfg["estimator"], cfg["params"],
        n_iter=20, scoring="f1_macro",
        cv=kf, random_state=42, n_jobs=-1
    )
    search.fit(Xc_train, yc_train)

    best_models[name] = search.best_estimator_
    pred = best_models[name].predict(Xc_test)

    search_results.append({
        "Model": name,
        "BestCV_F1": search.best_score_,
        "Test_F1": f1_score(yc_test, pred, average="macro"),
        "Test_Acc": accuracy_score(yc_test, pred),
        "BestParams": search.best_params_
    })

cls_results = pd.DataFrame(search_results).sort_values("Test_F1", ascending=False)
cls_results

"""# Step 14: Classification Report + Confusion Matrix

In this step, we take the best-performing classification model found during hyperparameter tuning and evaluate how well it predicts owl residency types (Vagrant / Migrant / Resident). First, the model predicts classes on the test set. Then, we force scikit-learn to display all three classes in the report—even if one class is missing in the test data—so the output always stays consistent. The classification report summarizes accuracy, precision, recall, and F1-scores for each class. Finally, we generate a confusion matrix heatmap, which visually shows how many owls were correctly or incorrectly classified in each category. This plot helps us quickly see where the model performs well and where it struggles.
"""

best_cls_name = cls_results.iloc[0]["Model"]
best_cls = best_models[best_cls_name]

yc_pred = best_cls.predict(Xc_test)

# FIX → FORCE SKLEARN TO PRINT ALL 3 CLASSES EVEN IF TEST IS MISSING ONE
all_labels = np.arange(len(le.classes_))  # [0,1,2] for Vagrant, Migrant, Resident

print(classification_report(
    yc_test,
    yc_pred,
    labels=all_labels,
    target_names=le.classes_,
    zero_division=0
))

# Confusion Matrix (forces class order)
cm = confusion_matrix(yc_test, yc_pred, labels=all_labels)

plt.figure(figsize=(5,4))
sns.heatmap(cm, annot=True, fmt="d",
            xticklabels=le.classes_,
            yticklabels=le.classes_)
plt.xlabel("Predicted")
plt.ylabel("True")
plt.title(f"Confusion Matrix — {best_cls_name}")
plt.show()

"""# Step 15. Exporting the Final Dataset

In this final step, we saved our fully processed owl dataset—which includes all engineered features, true stay durations, and classification labels—into a clean CSV file. This exported file can now be used for future analysis, modelling, or sharing with teammates
"""

owl_df.to_csv("final_true_duration_dataset.csv", index=False)
print("Saved: final_true_duration_dataset.csv")

"""# Visualizations"""

plt.figure(figsize=(6,4))
owl_df["ResidencyType_true"].value_counts().plot(kind="bar")
plt.title("True Residency Type Distribution (New Motus Data)")
plt.ylabel("Owls")
plt.show()

plt.figure(figsize=(7,6))
plt.scatter(y_test, best_pred, alpha=0.7, edgecolor="black")
plt.xlabel("True Stay Duration (days)")
plt.ylabel("Predicted Stay Duration (days)")
plt.title(f"Regression: True vs Predicted Stay Duration\nModel = {best_reg_name}")
plt.grid(True)
plt.show()

residuals = y_test - best_pred

plt.figure(figsize=(7,5))
sns.histplot(residuals, kde=True, bins=15)
plt.title("Residual Distribution (True - Predicted)")
plt.xlabel("Error (days)")
plt.ylabel("Count")
plt.grid(True)
plt.show()

all_labels = np.arange(len(le.classes_))
class_names = le.classes_

cm = confusion_matrix(yc_test, yc_pred, labels=all_labels)

plt.figure(figsize=(6,5))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues",
            xticklabels=class_names,
            yticklabels=class_names)
plt.xlabel("Predicted Class")
plt.ylabel("True Class")
plt.title(f"Confusion Matrix — {best_cls_name}")
plt.show()

plt.figure(figsize=(6,5))
owl_df["ResidencyType_true"].value_counts().plot(kind="pie", autopct="%1.0f%%", colors=["#66c2a5","#fc8d62","#8da0cb"])
plt.title("How Owls Behave Based on Detected Stay Duration")
plt.ylabel("")
plt.show()

top15 = owl_df.sort_values("stay_duration_days", ascending=False).head(15)

plt.figure(figsize=(10,6))
sns.barplot(data=top15, x="motusTagID", y="stay_duration_days", palette="viridis")
plt.title("Top 15 Owls by Number of Days Stayed")
plt.xlabel("Owl ID")
plt.ylabel("Stay Duration (days)")
plt.xticks(rotation=45)
plt.show()

df["DATETIME"] = pd.to_datetime(df["DATETIME"], errors="coerce")
df["hour"] = df["DATETIME"].dt.hour

plt.figure(figsize=(9,4))
sns.histplot(df["hour"], bins=24, kde=False, color="teal")
plt.title("What Time of Day Owls Are Most Active")
plt.xlabel("Hour of Day")
plt.ylabel("Detections")
plt.show()

df["date_only"] = df["DATETIME"].dt.date

daily = df.groupby("date_only")["motusTagID"].count().reset_index()

plt.figure(figsize=(12,5))
plt.plot(daily["date_only"], daily["motusTagID"], marker="o", color="brown")
plt.title("Daily Owl Activity at the Station")
plt.xlabel("Date")
plt.ylabel("Number of Detections")
plt.grid(True)
plt.xticks(rotation=45)
plt.show()